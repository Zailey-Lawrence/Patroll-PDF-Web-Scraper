import json
import os
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from typing import List, Dict, Any
import logging

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# Configuration
CURRENT_DATA_FILE = "won_patent_contests.json"
SNAPSHOT_DATA_FILE = "last_known_won_patent_contests.json"

# Email configuration (use environment variables for security)
SENDER_EMAIL = os.getenv("SCRAPER_SENDER_EMAIL", "")
RECEIVER_EMAIL = os.getenv("SCRAPER_RECEIVER_EMAIL", "")
EMAIL_PASSWORD = os.getenv("SCRAPER_EMAIL_PASSWORD", "")
SMTP_SERVER = "smtp.gmail.com"
SMTP_PORT = 465


def load_contests(filepath: str) -> List[Dict[str, Any]]:
    """
    Load contests list from a JSON file.
    
    Args:
        filepath: Path to the JSON file
        
    Returns:
        List of contest dictionaries
    """
    try:
        if os.path.exists(filepath):
            with open(filepath, 'r', encoding='utf-8') as f:
                data = json.load(f)
                contests = data.get("contests", [])
                logger.info(f"Loaded {len(contests)} contests from {filepath}")
                return contests
        else:
            logger.warning(f"File {filepath} does not exist")
            return []
    except json.JSONDecodeError as e:
        logger.error(f"Error parsing JSON from {filepath}: {e}")
        return []
    except Exception as e:
        logger.error(f"Error loading contests from {filepath}: {e}")
        return []


def detect_new_contests(current_contests: List[Dict[str, Any]], 
                       last_known_contests: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
    """
    Find contests in current data that are not in the last snapshot.
    
    Args:
        current_contests: Current contest data
        last_known_contests: Previously known contest data
        
    Returns:
        List of new contests
    """
    known_links = {c.get('contestLink', '') for c in last_known_contests}
    new_contests = [c for c in current_contests if c.get('contestLink', '') not in known_links]
    
    logger.info(f"Found {len(new_contests)} new contests out of {len(current_contests)} total")
    return new_contests


def create_email_content(new_contests: List[Dict[str, Any]]) -> tuple[str, str]:
    """
    Create formatted email subject and body for new contests.
    
    Args:
        new_contests: List of new contest dictionaries
        
    Returns:
        Tuple of (subject, body)
    """
    subject = f"ðŸš¨ New Won Patent Contests Detected ({len(new_contests)})"
    
    body = f"""
    <html>
    <body>
    <h2>New Won Patent Contests Detected</h2>
    <p>The following <strong>{len(new_contests)}</strong> new won patent contests were detected:</p>
    
    <table border="1" cellpadding="8" cellspacing="0" style="border-collapse: collapse;">
    <tr style="background-color: #f2f2f2;">
        <th>Contest Title</th>
        <th>Patent ID</th>
        <th>Prior Art</th>
        <th>Link</th>
    </tr>
    """
    
    for i, contest in enumerate(new_contests, 1):
        title = contest.get('contestTitle', 'N/A')
        patent_id = contest.get('patentID', 'N/A')
        prior_art = contest.get('priorArtID', 'N/A')[:100] + "..." if len(contest.get('priorArtID', '')) > 100 else contest.get('priorArtID', 'N/A')
        link = contest.get('contestLink', 'N/A')
        
        body += f"""
        <tr>
            <td>{title}</td>
            <td>{patent_id}</td>
            <td>{prior_art}</td>
            <td><a href="{link}">View Contest</a></td>
        </tr>
        """
    
    body += """
    </table>
    
    <p><em>This notification was automatically generated by the Patroll Scraper.</em></p>
    </body>
    </html>
    """
    
    return subject, body


def send_email_notification(new_contests: List[Dict[str, Any]]) -> bool:
    """
    Send email notification for new contests.
    
    Args:
        new_contests: List of new contest dictionaries
        
    Returns:
        True if email sent successfully, False otherwise
    """
    if not new_contests:
        logger.info("No new contests to notify about")
        return True

    if not all([SENDER_EMAIL, RECEIVER_EMAIL, EMAIL_PASSWORD]):
        logger.error("Email configuration incomplete. Please set environment variables.")
        return False

    try:
        subject, body = create_email_content(new_contests)
        
        # Create message
        msg = MIMEMultipart('alternative')
        msg["Subject"] = subject
        msg["From"] = SENDER_EMAIL
        msg["To"] = RECEIVER_EMAIL
        
        # Attach HTML content
        html_part = MIMEText(body, "html")
        msg.attach(html_part)

        # Send email
        with smtplib.SMTP_SSL(SMTP_SERVER, SMTP_PORT) as server:
            server.login(SENDER_EMAIL, EMAIL_PASSWORD)
            server.sendmail(SENDER_EMAIL, RECEIVER_EMAIL, msg.as_string())

        logger.info(f"Successfully sent email notification for {len(new_contests)} new contests")
        return True
        
    except Exception as e:
        logger.error(f"Failed to send email notification: {e}")
        return False


def update_snapshot(current_contests: List[Dict[str, Any]]) -> bool:
    """
    Update the snapshot file with current contest data.
    
    Args:
        current_contests: Current contest data
        
    Returns:
        True if snapshot updated successfully, False otherwise
    """
    try:
        snapshot_data = {
            "contests": current_contests,
            "total_contests": len(current_contests),
            "last_updated": json.dumps({"timestamp": "auto-generated"})
        }
        
        with open(SNAPSHOT_DATA_FILE, 'w', encoding='utf-8') as f:
            json.dump(snapshot_data, f, indent=2, ensure_ascii=False)
            
        logger.info(f"Updated snapshot with {len(current_contests)} contests")
        return True
        
    except Exception as e:
        logger.error(f"Failed to update snapshot: {e}")
        return False


def main() -> None:
    """Main notification workflow."""
    logger.info("Starting contest notification check...")
    
    # Load current and last known contests
    current_contests = load_contests(CURRENT_DATA_FILE)
    last_known_contests = load_contests(SNAPSHOT_DATA_FILE)

    if not current_contests:
        logger.warning("No current contest data found. Exiting.")
        return

    # Detect new contests
    new_contests = detect_new_contests(current_contests, last_known_contests)

    # Send notification if new contests found
    if new_contests:
        email_sent = send_email_notification(new_contests)
        if email_sent:
            logger.info("Email notification sent successfully")
        else:
            logger.error("Failed to send email notification")
    else:
        logger.info("No new contests found")

    # Update snapshot regardless of notification status
    snapshot_updated = update_snapshot(current_contests)
    if not snapshot_updated:
        logger.error("Failed to update snapshot file")

    logger.info("Contest notification check completed")


if __name__ == "__main__":
    main()
